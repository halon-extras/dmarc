import { AuthenticationResults } from "extras://authentication-results";

function dmarc($mail, $ipaddr, $helo, $mfrom)
{
	$result = [];
	$headers = $mail->getHeaders("from", ["decode" => false]);
	if (length($headers) == 0)
	{
		$result["result"] = "permerror";
		$result["reason"] = "No [MAIL].From header";
		return $result;
	}
	if (length($headers) > 1)
	{
		$result["result"] = "permerror";
		$result["reason"] = "Too many [MAIL].From headers";
		return $result;
	}

	$fromAddresses = header_addresslist_extract($headers[0]);
	if ($fromAddresses === none)
	{
		$result["result"] = "permerror";
		$result["reason"] = "Bad [MAIL].From address";
		return $result;
	}
	if (length($fromAddresses) == 0)
	{
		$result["result"] = "permerror";
		$result["reason"] = "No [MAIL].From address";
		return $result;
	}
	if (length($fromAddresses) > 1)
	{
		$result["result"] = "permerror";
		$result["reason"] = "Too many [MAIL].From addresses";
		return $result;
	}
	$split = str_split($fromAddresses[0], "@", -2);
	if (length($split) != 2 or $split[1] == "")
	{
		$result["result"] = "permerror";
		$result["reason"] = "Bad [MAIL].From address: no domain";
		return $result;
	}
	$senderdomain = idna_encode(str_lower($split[1]));
	if (!$senderdomain)
	{
		$result["result"] = "permerror";
		$result["reason"] = "Bad [MAIL].From domain";
		return $result;
	}
	$helo = str_lower($helo ?? "");
	$mfrom = str_lower($mfrom ?? "");

	$result["from"] = $senderdomain;
	$result["pdomain"] = $senderdomain;
	$info = [];

	$lookup = dns_query("_dmarc." . $senderdomain, ["type" => "txt"]);
	$domainOrg = none;

	if (!$lookup["result"] or !($tagList = getValidDMARCRecord($lookup["result"])))
	{
		$domainOrg = organizationalDomain($senderdomain);
		if (!$domainOrg)
		{
			if ($lookup["error"] == "SERVFAIL" or $lookup["error"] == "TRY_AGAIN")
			{
				$result["result"] = "temperror";
				$result["reason"] = "DMARC TXT record resolving: ". $lookup["error"];
				return $result;
			}
			$result["result"] = "policy_absent";
			$result["reason"] = "No valid DMARC record";
			return $result;
		}
		$result["pdomain"] = $domainOrg;

		$lookup = dns_query("_dmarc." . $domainOrg, ["type" => "txt"]);
		if (!$lookup["result"])
		{
			if ($lookup["error"] == "SERVFAIL" or $lookup["error"] == "TRY_AGAIN")
			{
				$result["result"] = "temperror";
				$result["reason"] = "DMARC TXT record resolving: ". $lookup["error"];
				return $result;
			}
			$result["result"] = "policy_absent";
			$result["reason"] = "No valid DMARC record";
			return $result;
		}

		if (!($tagList = getValidDMARCRecord($lookup["result"])))
		{
			$result["result"] = "policy_absent";
			$result["reason"] = "No valid DMARC record";
			return $result;
		}
		$result["dmarc"] = $tagList;
	}
	else
		$result["dmarc"] = $tagList;

	$tagp = $domainOrg ? $tagList["sp"] ?? $tagList["p"] : $tagList["p"];
	if (!$tagp)
	{
		$result["result"] = "policy_absent";
		$result["reason"] = "p= is missing";
		return $result;
	}

	$strictSPF = $tagList["aspf"] == "s";
	$strictDKIM = $tagList["adkim"] == "s";
	$pct = $tagList["pct"] ? number($tagList["pct"]) : 100;

	$passSPF = false; $passDKIM = false;
	$checkSPF = false; $checkDKIM = false;
	$temperrorSPF = false; $temperrorDKIM = false;

	if (checkIdentifierAligment($mfrom ? $mfrom : $helo, $senderdomain, $strictSPF)) {
		$checkSPF = true;
		$spf = spf_query($ipaddr, $helo, $mfrom);
		if ($spf["result"] == "pass")
			$passSPF = true;
		if ($spf["result"] == "temperror")
			$temperrorSPF = true;
		$result["spf"] = $spf;
	}

	foreach ($mail->getHeaders("DKIM-Signature") as $x => $header)
	{
		$dkim = header_dkim_decode($header);
		if (!$dkim or !$dkim["d"])
			continue;
		$dkimdomain = idna_encode(str_lower($dkim["d"]));
		if (!$dkimdomain)
			continue;
		if (!checkIdentifierAligment($dkimdomain, $senderdomain, $strictDKIM))
			continue;

		$checkDKIM = true;
		$r = $mail->verifyDKIM($mail->getHeader("DKIM-Signature", ["index" => $x, "field" => true]));

		$result["dkim"][] = $r;
		if ($r["result"] == "pass")
		{
			$passDKIM = true;
			break;
		}
		if ($r["result"] == "temperror")
			$temperrorDKIM = true;
	}

	$selected = ($pct == 100 or rand(0, 100) < $pct);
	$result["pct-selected"] = $selected;

	$action = "pass";
	if (!$passSPF and !$passDKIM) {
		if ($temperrorSPF or $temperrorDKIM)
			$action = "temperror";
		else if ($tagp == "reject")
			$action = $selected ? "reject" : "quarantine";
		else if ($tagp == "quarantine")
			$action = $selected ? "quarantine" : "none";
		else if ($tagp == "none")
			$action = "none";
		else
			$action = "none";
	}

	$result["spf_align"] = $checkSPF ? ($passSPF ? "pass": "fail") : "unaligned";
	$result["dkim_align"] = $checkDKIM ? ($passDKIM ? "pass": "fail") : "unaligned";
	$result["result"] = $action;
	$result["policy"] = $tagp;

	return $result;
}

function dmarc_ruf_candidate($dmarc)
{
	if ($dmarc["result"] == "policy_absent" or
		$dmarc["result"] == "none" or
		$dmarc["result"] == "accept")
		return ["result" => false, "reason" => "pass: no report to send"];
	if (!$dmarc["dmarc"]["ruf"])
		return ["result" => false, "reason" => "ruf is not specified"];
	if ($dmarc["dmarc"]["rf"] ?? "afrf" != "afrf")
		return ["result" => false, "reason" => "unsupported report format"];
	$report = false;
	foreach (str_split($dmarc["dmarc"]["fo"] ?? "0", ",") as $fo)
	{
		switch ($fo)
		{
			case "0":
				if ($dmarc["spf_align"] != "pass" or $dmarc["dkim_align"] != "pass")
					$report = true;
			break;
			case "1":
				if ($dmarc["spf_align"] != "pass" and $dmarc["dkim_align"] != "pass")
					$report = true;
			break;
			case "d":
			case "s":
				return ["error" => "unsupported reporting"];
		}
		if ($report)
			break;
	}
	if (!$report)
		return ["result" => false, "reason" => "not report to sent based on failure reporting options"];
	return ["result" => true];
}

function dmarc_ruf_addresses($dmarc)
{
	$addresses = [];
	if ($dmarc["dmarc"]["ruf"])
		$addresses = array_map(function($str) { return envelope_address_parse($str[7:]); }, array_filter(function ($str) { return $str[0:7] == "mailto:"; }, str_split($dmarc["dmarc"]["ruf"], ",")));
	$addresses = array_filter(function($address) closure ($dmarc) {
			if (!$address)
				return false;
			if ($dmarc["pdomain"] == $address["domain"])
				return true;
			$dns = dns_query($dmarc["pdomain"]."._report._dmarc.".$address["domain"], ["type" => "txt"]);
			if (header_dkim_decode($dns["result"][0])["v"] != "DMARC1")
				return false;
			return true;
		}, $addresses);
	return ["result" => $addresses];
}

function dmarc_ruf_report($dmarc, $ip, $mfrom, $rcptto, $ts, $mail, $options = [])
{
	$report = MIME();
	$report->setType("message/feedback-report");
	$headers = MailMessage::String("");

	// Additional for DMARC
	$headers->addHeader("Identity-Alignment", array_join([...($dmarc["spf_align"] == "pass" ? ["spf"] : []), ...($dmarc["dkim_align"] == "pass" ? ["dkim"] : [])], ",") ?: "none");
	// SPF-DNS (missing from report)
	if ($dmarc["dkim"][0]["tags"]["d"] and $dmarc["dkim"][0]["tags"]["s"])
	{
		$headers->addHeader("DKIM-Selector", $dmarc["dkim"][0]["tags"]["s"]);
		if ($dmarc["dkim"][0]["tags"]["i"])
			$headers->addHeader("DKIM-Identity", $dmarc["dkim"][0]["tags"]["i"]);
		$headers->addHeader("DKIM-Domain", $dmarc["dkim"][0]["tags"]["d"]);
	}
	$headers->addHeader("Delivery-Result", $options["delivery-result"] ?? "reject");

	// Optional
	$headers->addHeader("Reported-Domain", $dmarc["pdomain"]);
	$headers->addHeader("Authentication-Results", AuthenticationResults()->DMARC($dmarc)->toString(["multiline" => false]));
	$headers->addHeader("Source-IP", $ip);
	$headers->addHeader("Arrival-Date", strftime("%a, %d %b %Y %X %z", $ts));
	$headers->addHeader("Original-Rcpt-To", "<".envelope_localpart_escape($rcptto["localpart"])."@".$rcptto["domain"].">");
	if (!$mfrom["localpart"])
		$headers->addHeader("Original-Mail-From", "<>");
	else
		$headers->addHeader("Original-Mail-From", "<".envelope_localpart_escape($mfrom["localpart"])."@".$mfrom["domain"].">");

	// Required
	$headers->addHeader("Version", "1");
	$headers->addHeader("User-Agent", "Halon DMARC");
	$headers->addHeader("Feedback-Type", "auth-failure");

	$report->setBody(str_strip($headers->toString()));
	return $report;
}

function organizationalDomain($domain)
{
	$publicSuffix = domain_publicsuffix($domain);
	if ($publicSuffix == none)
		return none;

	$domainParts = str_split($domain, ".");
	$domainTLD = str_split($publicSuffix, ".");
	if (length($domainTLD) == length($domainParts))
		return none;

	$domainOrg = array_join($domainParts[-length($domainTLD) - 1:], ".");
	if ($domainOrg == $domain)
		return none;
	
	return $domainOrg;
}

function checkIdentifierAligment($domain1, $domain2, $strict)
{
	if ($strict)
		return $domain1 == $domain2;

	$domainOrg1 = organizationalDomain($domain1);
	$domainOrg1 = $domainOrg1 ?? $domain1;
	$domainOrg2 = organizationalDomain($domain2);
	$domainOrg2 = $domainOrg2 ?? $domain2;

	return $domainOrg1 == $domainOrg2;
}

function getValidDMARCRecord($records)
{
	foreach ($records as $r)
	{
		$x = header_dkim_decode($r);
		$r = [];
		if (is_array($x))
		{
			foreach ($x as $k => $v)
			{
				$k = str_lower($k);
				$r[$k] = match ($k) {
					"v" => $v, /* case sensitive */
					"adkim", "aspf", "fo", "p", "rf", "sp" => str_lower($v),
					default => $v /* other fields, leave as is for now... */
				};
			}
		}
		if (isset($r["v"]) and $r["v"] == "DMARC1")
			return $r;
	}
	return none;
}
